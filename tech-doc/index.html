<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Technical Documentation</title>

  <link rel="stylesheet" href="style.css">
</head>

<body>
  <nav id="navbar">
    <header>Python Doc</header>
    <ul>
      <li><a class="nav-link" href="#Introduction" rel="internal">Introduction</a></li>
      <li><a class="nav-link" href="#Data_Model" rel="internal">Data Model</a></li>
      <li><a class="nav-link" href="#Execution_Model" rel="internal">Execution Model</a></li>
      <li><a class="nav-link" href="#Import_System" rel="internal">Import System</a></li>
      <li><a class="nav-link" href="#Simple_Statements" rel="internal">Simple Statements</a></li>
    </ul>
  </nav>

  <main id="main-doc">
    <section class="main-section" id="Introduction">
      <header>Introduction</header>
      <article>
        <p>This reference manual describes the Python programming language. It is not intended as a tutorial.</p>
        <p>While I am trying to be as precise as possible, I chose to use English rather than formal specifications for everything except syntax and lexical analysis. This should make the document more understandable to the average reader, but will leave room for ambiguities. Consequently, if you were coming from Mars and tried to re-implement Python from this document alone, you might have to guess things and in fact you would probably end up implementing quite a different language. On the other hand, if you are using Python and wonder what the precise rules about a particular area of the language are, you should definitely be able to find them here. If you would like to see a more formal definition of the language, maybe you could volunteer your time — or invent a cloning machine :-).</p>
        <p>It is dangerous to add too many implementation details to a language reference document — the implementation may change, and other implementations of the same language may work differently. On the other hand, CPython is the one Python implementation in widespread use (although alternate implementations continue to gain support), and its particular quirks are sometimes worth being mentioned, especially where the implementation imposes additional limitations. Therefore, you’ll find short “implementation notes” sprinkled throughout the text.</p>
        <p>Every Python implementation comes with a number of built-in and standard modules. These are documented in The Python Standard Library. A few built-in modules are mentioned when they interact in a significant way with the language definition.</p>
      </article>
    </section>

    <section class="main-section" id="Data_Model">
      <header>Data Model</header>
      <article>
        <p>Objects are Python’s abstraction for data. All data in a Python program is represented by objects or by relations between objects. (In a sense, and in conformance to Von Neumann’s model of a “stored program computer,” code is also represented by objects.)</p>
        <p>Every object has an identity, a type and a value. An object’s identity never changes once it has been created; you may think of it as the object’s address in memory. The ‘is’ operator compares the identity of two objects; the id() function returns an integer representing its identity.</p>
      </article>
    </section>

    <section class="main-section" id="Execution_Model">
      <header>Execution Model</header>
      <article>
        <p>A Python program is constructed from code blocks. A block is a piece of Python program text that is executed as a unit. The following are blocks: a module, a function body, and a class definition. Each command typed interactively is a block. A script file (a file given as standard input to the interpreter or specified as a command line argument to the interpreter) is a code block. A script command (a command specified on the interpreter command line with the ‘-c’ option) is a code block. The string argument passed to the built-in functions eval() and exec() is a code block.</p>
      </article>
    </section>

    <section class="main-section" id="Import_System">
      <header>Import System</header>
      <article>
        <p>Python code in one module gains access to the code in another module by the process of importing it. The import statement is the most common way of invoking the import machinery, but it is not the only way. Functions such as importlib.import_module() and built-in __import__() can also be used to invoke the import machinery.</p>
        <p>The import statement combines two operations; it searches for the named module, then it binds the results of that search to a name in the local scope. The search operation of the import statement is defined as a call to the __import__() function, with the appropriate arguments. The return value of __import__() is used to perform the name binding operation of the import statement. See the import statement for the exact details of that name binding operation.</p>
        <p>A direct call to __import__() performs only the module search and, if found, the module creation operation. While certain side-effects may occur, such as the importing of parent packages, and the updating of various caches (including sys.modules), only the import statement performs a name binding operation.</p>
        <p>When calling __import__() as part of an import statement, the standard builtin __import__() is called. Other mechanisms for invoking the import system (such as importlib.import_module()) may choose to subvert __import__() and use its own solution to implement import semantics.</p>
      </article>
    </section>

    <section class="main-section" id="Simple_Statements">
      <header>Simple Statements</header>
      <article>
        <p>A simple statement is comprised within a single logical line. Several simple statements may occur on a single line separated by semicolons.</p>
        <ul>
          <li>Class</li>
          <code>
class Cls:
  x = 3             # class variable
  inst = Cls()
  inst.x = inst.x + 1   # writes inst.x as 4 leaving Cls.x as 3
          </code>
          <li>Print</li>
          <code>
x = [0, 1]
  i = 0
  i, x[i] = 1, 2         # i is updated, then x[i] is updated
  print(x)
          </code>
          <li>Assert</li> 
          <code>
if __debug__:
if not expression: raise AssertionError
          </code>
          <li>Yield</li>
          <code>
yield &lt;expr&gt;
yield from &lt;exp&gt;
          </code>
          <li>Import</li>
          <code>
import foo                 # foo imported and bound locally
import foo.bar.baz         # foo.bar.baz imported, foo bound locally
import foo.bar.baz as fbb  # foo.bar.baz imported and bound as fbb
from foo.bar import baz    # foo.bar.baz imported and bound as baz
from foo import attr       # foo imported and foo.attr bound as attr
          </code>
        </u>
        
      </article>
    </section>
  </main>


  <script src="script.js"></script>
  <script src="https://gitcdn.link/repo/freeCodeCamp/testable-projects-fcc/master/build/testable-projects-fcc/v1/bundle.js"></script>
</body>

</html>